{"ast":null,"code":"import _defineProperty from \"/Users/eandersson018/Documents/Workspace/eve/veyor/client/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport QueryString from 'query-string';\nimport fetchJsonp from 'fetch-jsonp';\nimport { data } from './mockData';\n/**\n * A method that calls an API endpoint with the specified method and params\n * @param  {String} endpoint       The URL to call\n * @params {Object}                Additional options\n */\n\nconst callApi = (endpoint, {\n  isJsonp = false,\n  method = 'get',\n  params = {}\n} = {}) => {\n  let reqBody = params;\n  let queryString = '';\n  const headers = {};\n\n  if (method === 'get') {\n    // We can't have a body on a get request as it will silently fail\n    reqBody = null;\n    if (params && Object.keys(params).length) queryString = \"?\".concat(QueryString.stringify(params));\n  } //return Promise.resolve(data)\n\n\n  console.log('calling endpoint', \"\".concat(endpoint).concat(queryString), 'jsonp', isJsonp);\n\n  if (!isJsonp) {\n    return fetch(\"\".concat(endpoint).concat(queryString), {\n      headers,\n      method,\n      body: reqBody\n    }).then(response => {\n      return response.ok ? response.json : response.json().then(json => Promise.reject(_objectSpread({}, response, {}, json)));\n    });\n  } else {\n    return fetchJsonp(\"\".concat(endpoint).concat(queryString), {\n      jsonpCallback: 'http://localhost:3000'\n    }).then(function (response) {\n      return response.json();\n    }).then(function (json) {\n      console.log('parsed json', json);\n    }).catch(function (ex) {\n      console.log('parsing failed', ex);\n    });\n  }\n};\n/**\n * This is a dispatch specific version of the callApi method that can be used with actions\n * It returns a function that matches the expected shape for a thunk action\n *\n * @method callApiWithDispatch\n * @param {Function} callback Should be a function of the form (dispatch, state, promise)\n *                            and return a promise\n */\n\n\nconst callApiWithDispatch = (endpoint, options = {}, callbackPromiseFunction) => {\n  return (dispatch, getState) => {\n    const state = getState();\n    options.params = options.params || {};\n    const apiPromise = callApi(endpoint, options, dispatch).then(result => result).catch(error => {\n      throw error;\n    });\n    const callbackPromise = callbackPromiseFunction ? callbackPromiseFunction(dispatch, state, apiPromise) : apiPromise;\n    if (!callbackPromise.then) throw Error('Callback function did not return a promise');\n    return callbackPromise;\n  };\n};\n\nexport { callApi, callApiWithDispatch };","map":{"version":3,"sources":["/Users/eandersson018/Documents/Workspace/eve/veyor/client/src/core/lib/apiHelpers.js"],"names":["QueryString","fetchJsonp","data","callApi","endpoint","isJsonp","method","params","reqBody","queryString","headers","Object","keys","length","stringify","console","log","fetch","body","then","response","ok","json","Promise","reject","jsonpCallback","catch","ex","callApiWithDispatch","options","callbackPromiseFunction","dispatch","getState","state","apiPromise","result","error","callbackPromise","Error"],"mappings":";;;;;;AAAA,OAAOA,WAAP,MAAwB,cAAxB;AACA,OAAOC,UAAP,MAAuB,aAAvB;AACA,SAASC,IAAT,QAAqB,YAArB;AAEA;;;;;;AAKA,MAAMC,OAAO,GAAG,CACdC,QADc,EAEd;AACEC,EAAAA,OAAO,GAAG,KADZ;AAEEC,EAAAA,MAAM,GAAG,KAFX;AAGEC,EAAAA,MAAM,GAAG;AAHX,IAII,EANU,KAOX;AACH,MAAIC,OAAO,GAAGD,MAAd;AACA,MAAIE,WAAW,GAAG,EAAlB;AAEA,QAAMC,OAAO,GAAG,EAAhB;;AAGA,MAAIJ,MAAM,KAAK,KAAf,EAAsB;AACpB;AACAE,IAAAA,OAAO,GAAG,IAAV;AACA,QAAID,MAAM,IAAII,MAAM,CAACC,IAAP,CAAYL,MAAZ,EAAoBM,MAAlC,EAA0CJ,WAAW,cAAOT,WAAW,CAACc,SAAZ,CAAsBP,MAAtB,CAAP,CAAX;AAC3C,GAXE,CAaJ;;;AAEAQ,EAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ,YAAmCZ,QAAnC,SAA8CK,WAA9C,GAA6D,OAA7D,EAAsEJ,OAAtE;;AAEC,MAAI,CAACA,OAAL,EAAc;AACZ,WAAOY,KAAK,WAAIb,QAAJ,SAAeK,WAAf,GAA8B;AAAEC,MAAAA,OAAF;AAAWJ,MAAAA,MAAX;AAAmBY,MAAAA,IAAI,EAAEV;AAAzB,KAA9B,CAAL,CACNW,IADM,CACDC,QAAQ,IAAI;AAChB,aAAOA,QAAQ,CAACC,EAAT,GACHD,QAAQ,CAACE,IADN,GAEHF,QAAQ,CAACE,IAAT,GAAgBH,IAAhB,CAAqBG,IAAI,IAAIC,OAAO,CAACC,MAAR,mBAAoBJ,QAApB,MAAiCE,IAAjC,EAA7B,CAFJ;AAGD,KALM,CAAP;AAMD,GAPD,MAOO;AACL,WAAOrB,UAAU,WAAIG,QAAJ,SAAeK,WAAf,GAA8B;AAC7CgB,MAAAA,aAAa,EAAE;AAD8B,KAA9B,CAAV,CAGNN,IAHM,CAGD,UAASC,QAAT,EAAmB;AACvB,aAAOA,QAAQ,CAACE,IAAT,EAAP;AACD,KALM,EAKJH,IALI,CAKC,UAASG,IAAT,EAAe;AACrBP,MAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ,EAA2BM,IAA3B;AACD,KAPM,EAOJI,KAPI,CAOE,UAASC,EAAT,EAAa;AACpBZ,MAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ,EAA8BW,EAA9B;AACD,KATM,CAAP;AAUD;AACF,CA3CD;AA6CA;;;;;;;;;;AAQA,MAAMC,mBAAmB,GAAG,CAACxB,QAAD,EAAWyB,OAAO,GAAG,EAArB,EAAyBC,uBAAzB,KAAqD;AAE/E,SAAO,CAACC,QAAD,EAAWC,QAAX,KAAwB;AAC7B,UAAMC,KAAK,GAAGD,QAAQ,EAAtB;AACAH,IAAAA,OAAO,CAACtB,MAAR,GAAiBsB,OAAO,CAACtB,MAAR,IAAkB,EAAnC;AAEA,UAAM2B,UAAU,GAAG/B,OAAO,CAACC,QAAD,EAAWyB,OAAX,EAAoBE,QAApB,CAAP,CAClBZ,IADkB,CACbgB,MAAM,IAAIA,MADG,EAElBT,KAFkB,CAEZU,KAAK,IAAI;AACd,YAAMA,KAAN;AACD,KAJkB,CAAnB;AAMA,UAAMC,eAAe,GAAGP,uBAAuB,GAC3CA,uBAAuB,CAACC,QAAD,EAAWE,KAAX,EAAkBC,UAAlB,CADoB,GAE3CA,UAFJ;AAIA,QAAI,CAACG,eAAe,CAAClB,IAArB,EAA2B,MAAMmB,KAAK,CAAC,4CAAD,CAAX;AAE3B,WAAOD,eAAP;AACD,GAjBD;AAkBD,CApBD;;AAsBA,SAASlC,OAAT,EAAkByB,mBAAlB","sourcesContent":["import QueryString from 'query-string'\nimport fetchJsonp from 'fetch-jsonp'\nimport { data } from './mockData'\n\n/**\n * A method that calls an API endpoint with the specified method and params\n * @param  {String} endpoint       The URL to call\n * @params {Object}                Additional options\n */\nconst callApi = (\n  endpoint,\n  {\n    isJsonp = false,\n    method = 'get',\n    params = {},\n  } = {}\n) => {\n  let reqBody = params\n  let queryString = ''\n\n  const headers = {\n  }\n\n  if (method === 'get') {\n    // We can't have a body on a get request as it will silently fail\n    reqBody = null\n    if (params && Object.keys(params).length) queryString = `?${QueryString.stringify(params)}`\n  }\n\n\t//return Promise.resolve(data)\n\n\tconsole.log('calling endpoint', `${endpoint}${queryString}`, 'jsonp', isJsonp)\n\n  if (!isJsonp) {\n    return fetch(`${endpoint}${queryString}`, { headers, method, body: reqBody })\n    .then(response => {\n      return response.ok\n        ? response.json\n        : response.json().then(json => Promise.reject({ ...response, ...json }))\n    })\n  } else {\n    return fetchJsonp(`${endpoint}${queryString}`, {\n      jsonpCallback: 'http://localhost:3000',\n    })\n    .then(function(response) {\n      return response.json()\n    }).then(function(json) {\n      console.log('parsed json', json)\n    }).catch(function(ex) {\n      console.log('parsing failed', ex)\n    })\n  }\n}\n\n/**\n * This is a dispatch specific version of the callApi method that can be used with actions\n * It returns a function that matches the expected shape for a thunk action\n *\n * @method callApiWithDispatch\n * @param {Function} callback Should be a function of the form (dispatch, state, promise)\n *                            and return a promise\n */\nconst callApiWithDispatch = (endpoint, options = {}, callbackPromiseFunction) => {\n\n  return (dispatch, getState) => {\n    const state = getState()\n    options.params = options.params || {}\n\n    const apiPromise = callApi(endpoint, options, dispatch)\n    .then(result => result)\n    .catch(error => {\n      throw error\n    })\n\n    const callbackPromise = callbackPromiseFunction\n      ? callbackPromiseFunction(dispatch, state, apiPromise)\n      : apiPromise\n\n    if (!callbackPromise.then) throw Error('Callback function did not return a promise')\n\n    return callbackPromise\n  }\n}\n\nexport { callApi, callApiWithDispatch }\n"]},"metadata":{},"sourceType":"module"}